<!---

Dirichlet Disks for Lissajous-toric knots

This makes a simple webapp that plots an immersed disk bounded by a Lissajous-Toric knot


		--->


<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Lissajous-toric disks</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
		#infoBox {
		  position: absolute;
		  top: 10px;
		  left: 10px;
		  width: 300px;
		  background: rgba(255, 255, 255, 0.8);
		  padding: 5px;
		  border-radius: 5px;
		  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
		  z-index: 100;
		}
		#toggleButton {
		  position: absolute;
		  top: 10px;
		  left: 330px;
		  cursor: pointer;
		  background: #ccc;
		  padding: 5px;
		  border-radius: 3px;
		}
    </style>
    <!-- Import map: Map the bare specifier "three" -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.0/build/three.module.js"
        }
      }
    </script>
  </head>
  <body>
		  <div id="infoBox"> 
				  <h3> Lissajous-toric knots </h3>
				  Given \(H,p,q \in \mathbb{Z}\) and \(\phi \in \mathbb{R}\), consider the parametized curve \(\gamma : [0,2\pi] \rightarrow \mathbb{R}^3\) via the coordinate functions

				  \[x(t) = (2+\sin(qt))\cos(Ht)\]  \[y(t) = (2+\sin(qt))\sin(Ht) \]  \[z(t) = \cos(p(t+\phi)) \]  

				When \(\gcd(H,p)=\gcd(H,q)=1\) and \(\phi\) chosen so that \(\gamma\) does not self-intersect, the curve \(\gamma\) parametrizes  
				  the <b>Lissajous-toric knot</b> \(K(H,p,q,\phi)\). <br> <br>
				  Plotted right is a singular disk associated with our parametrization of \(K(H,p,q,0.1)\). Thinking of the unit disk as a subset of the complex plane, the map \(\mathbb{D}^2 \rightarrow \mathbb{R}^3\) is defined by coordinate functions \(X(w),Y(w),Z(w)\) are obtained by solving the Dirichlet boundary problem for the disk: \[ \nabla^2 F = 0 \qquad F|_{\partial \mathbb{D}^2} = f\] where \(f\) is the result of precomposing any of \(x,y,z\) with the complex logarithm with standard branch cut.
		  </div>
		  <script type="text/javascript" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
<div id="toggleButton">Hide</div>
	<script>
		document.getElementById("toggleButton").addEventListener("click", function () {
				const infoBox = document.getElementById("infoBox");
				if (infoBox.style.display === "none") {
						infoBox.style.display = "block";
						this.textContent = "Hide";
				} else {
						infoBox.style.display = "none";
						this.textContent = "Show";
				}
		});
	</script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "https://unpkg.com/three@0.150.0/examples/jsm/controls/OrbitControls.js";
      import { GUI } from "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js";
      import { OBJExporter } from "https://unpkg.com/three@0.150.0/examples/jsm/exporters/OBJExporter.js";

      let scene, camera, renderer, controls;
      let knotMesh, surfaceMesh;
      // Default parameters.
      let params = {
        H: 7,
        p: 6,
        q: 19,
        radialSegments: 50,
        angularSegments: 500,
        backgroundColor: "#161622",
		opacity: 1
      };

      init();
      animate();

      // A helper function to avoid powers of zero.
      function safePow(r, exp) {
        return Math.pow(Math.max(r, 1e-6), exp);
      }

      function init() {
        // Create scene and set background color.
        scene = new THREE.Scene();
        scene.background = new THREE.Color(params.backgroundColor);

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(10, 10, 10);
        camera.lookAt(scene.position);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);

        // Create the boundary knot and the surface.
        knotMesh = createKnot(params.H, params.p, params.q, params.angularSegments);
        scene.add(knotMesh);
        surfaceMesh = createSurface(
          params.H,
          params.p,
          params.q,
          params.radialSegments,
          params.angularSegments,
		  params.opacity
        );
        scene.add(surfaceMesh);

        // Basic lighting.
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);

        // Set up dat.GUI.
        const gui = new GUI();
        gui.add(params, "H", 1, 30, 1).onChange(updateModel);
        gui.add(params, "p", 1, 30, 1).onChange(updateModel);
        gui.add(params, "q", 2, 50, 1).onChange(updateModel);
        // gui.add(params, "radialSegments", 10, 100, 1).onChange(updateModel);
        gui.add(params, "angularSegments", 20, 1000, 1).onChange(updateModel);
		gui.add(params, "opacity", 0, 1, 0.01).onChange(updateModel);
        gui.addColor(params, "backgroundColor").onChange((value) => {
          scene.background.set(value);
        });
        // gui.add({ download: downloadOBJ }, "download").name("Download .obj");

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      // Create the boundary curve (black line) using the harmonic formulas at r = 1.
      function createKnot(H, p, q, angularSegments) {
        const points = [];
        for (let j = 0; j <= angularSegments; j++) {
          const theta = (j / angularSegments) * 2 * Math.PI;
          const ux =
            2 * Math.cos(H * theta) +
            0.5 * Math.sin((q + H) * theta) +
            0.5 * Math.sign(q - H) * Math.sin(Math.abs(q - H) * theta);
          const uy =
            2 * Math.sin(H * theta) -
            0.5 * Math.cos((q + H) * theta) +
            0.5 * Math.sign(q - H) * Math.cos(Math.abs(q - H) * theta);
          const uz = 2 * Math.cos(p * theta + 0.1);
          points.push(new THREE.Vector3(ux, uy, uz));
        }
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0x000000 });
        return new THREE.LineLoop(geometry, material);
      }

      // Create the surface mesh using the harmonic extension.
      function createSurface(H, p, q, radialSegments, angularSegments, opacity) {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];

        // Loop over a polar grid on the unit disk.
        for (let i = 0; i <= radialSegments; i++) {
          const r = i / radialSegments;
          for (let j = 0; j <= angularSegments; j++) {
            const theta = (j / angularSegments) * 2 * Math.PI;
            const term1_x = 2 * safePow(r, H) * Math.cos(H * theta);
            const term2_x = 0.5 * safePow(r, q + H) * Math.sin((q + H) * theta);
            const term3_x =
              0.5 *
              Math.sign(q - H) *
              safePow(r, Math.abs(q - H)) *
              Math.sin(Math.abs(q - H) * theta);
            const ux = term1_x + term2_x + term3_x;

            const term1_y = 2 * safePow(r, H) * Math.sin(H * theta);
            const term2_y = -0.5 * safePow(r, q + H) * Math.cos((q + H) * theta);
            const term3_y =
              0.5 *
              Math.sign(q - H) *
              safePow(r, Math.abs(q - H)) *
              Math.cos(Math.abs(q - H) * theta);
            const uy = term1_y + term2_y + term3_y;

            const uz = 2 * safePow(r, p) * Math.cos(p * theta + 0.1);

            vertices.push(ux, uy, uz);
          }
        }

        const indices = [];
        for (let i = 0; i < radialSegments; i++) {
          for (let j = 0; j < angularSegments; j++) {
            const a = i * (angularSegments + 1) + j;
            const b = a + angularSegments + 1;
            indices.push(a, b, a + 1);
            indices.push(b, b + 1, a + 1);
          }
        }
        geometry.setIndex(indices);
        geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        geometry.computeVertexNormals();

        // Use MeshNormalMaterial with double-sided rendering.
        const material = new THREE.MeshNormalMaterial({ transparent: true, opacity: opacity, side: THREE.DoubleSide});
        return new THREE.Mesh(geometry, material);
      }

      // Export the current model as an OBJ file for Blender.
      function downloadOBJ() {
        const exporter = new OBJExporter();
        // Group both meshes into one object.
        const group = new THREE.Group();
        group.add(knotMesh.clone());
        group.add(surfaceMesh.clone());
        const objString = exporter.parse(group);
        const blob = new Blob([objString], { type: "text/plain" });
        const link = document.createElement("a");
        // Generate a filename that includes H, p, q, radialSegments, and angularSegments.
        const filename = `model_H${params.H}_p${params.p}_q${params.q}_rs${params.radialSegments}_as${params.angularSegments}.obj`;
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Rebuild the knot and surface when UI parameters change.
      function updateModel() {
        if (knotMesh) scene.remove(knotMesh);
        if (surfaceMesh) scene.remove(surfaceMesh);
        knotMesh = createKnot(params.H, params.p, params.q, params.angularSegments);
        surfaceMesh = createSurface(
          params.H,
          params.p,
          params.q,
          params.radialSegments,
          params.angularSegments,
		  params.opacity
        );
        scene.add(knotMesh);
        scene.add(surfaceMesh);
      }
    </script>
  </body>
</html>
